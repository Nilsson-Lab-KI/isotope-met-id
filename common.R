#
#  Some functions commonly used in these scripts
#
# NOTE: Some of these could be moved to the remn package
#

library(dplyr)
library(ggplot2)
library(midist)
library(plotly)
library(stringr)
library(tidyr)
library(umap)

# data folder common paths

input_data_path <- "00_input_data"
preprocessed_data_path <- "01_preprocessed_data"
mi_data_path <- "02_mi_data"
mid_distance_path <- "03_mid_distance"
gold_standard_path <- "04_gold_standard"
sim_mid_distance_path <- "05_sim_mid_distance"


# constants
proton_mass <- 1.007276466621
h2o_mass <- 18.010564683
nh4_mass <- 18.034374132
ppm_tolerance <- 10


create_dir_if_not_exists <- function(dir_path)
{
   if(!file.exists(dir_path))
      dir.create(dir_path, recursive = TRUE)
}


read_tsv <- function(file_path)
{
    return(
        read.table(
            file_path,
            sep = "\t", header = TRUE, comment.char = "", quote = ""
        )
    ) 
}

# peak area data from the HMEC isotope tracing experiment
read_hmec_peak_areas <- function()
{
    return(
        read_tsv(
            file.path(preprocessed_data_path, "qc-peak-areas.tsv")
        )
    )
}

# peak list from the HMEC isotope tracing experiment
read_hmec_peak_list <- function()
{
    return(
        read_tsv(
            file.path(preprocessed_data_path, "hmec_peak_list.tsv")
        ) %>% mutate(peak_id = as.character(peak_id))
    )
}

# peak to HMDB compound annotations
read_peak_hmdb_compound <- function()
{
    return(
        read_tsv(
            file.path(preprocessed_data_path, "peak_hmdb_compound.tsv")
        ) %>% mutate(peak_id = as.character(peak_id))
    )
}

read_metabolite_pathway <- function()
{
    return(
        read_tsv(
            file.path(input_data_path, "simulation_metabolite_pathway.tsv")
        )
    )
}

read_plotly_tooltips <- function()
{
    return(
        read_tsv(file.path(preprocessed_data_path, "plotly_tooltips.tsv")) %>%
            tibble::column_to_rownames('peak_id') %>%
            mutate(tooltip = chartr("|", "\n", tooltip))
    )
}


get_mid_matrix <- function(mi_data, peak_id, experiments = NULL)
{
    return(
        do.call(cbind,
                lapply(
                    experiments,
                    function(e) get_mids(mi_data, peak_id, e)
                )
        )
    )
}


# convolute MID matrices column by column
convolute_all <- function(mids_1, mids_2)
{
    sapply(
        1:ncol(mids_1),
        function(i) convolute(mids_1[, i], mids_2[, i])
    )
}

# write matrix as PNG image (for Illustrator) after applying a color function
# such as those generated by colorRamp()
# rows of the matrix are laid out from top to bottom.
write_image <- function(file_path, mat, color_fn)
{
    png::writePNG(
        aperm(
            apply(mat, c(1,2), color_fn) / 255,
            c(2,3,1)
        ),
        file_path
    )
}

reverse_rows <- function(mat)
{
    return(mat[nrow(mat):1, ])
}

# write an MID matrix, dropping M+0 and rescaling to [0, 1]
write_mid_matrix_image <- function(file_name, mids, max_mi_fraction = NULL)
{
    mat <- reverse_rows(c13correct_cols(mids)[-1, ])
    if(is.null(max_mi_fraction))
        max_mi_fraction <- max(mat)
    write_image(
        file_name,
        pmin(mat, max_mi_fraction) / max_mi_fraction,
        colorRamp(c("white", "red"))
    )
}

# UMap projection

umap_projection <- function(dm, n_neighbors, random_seed = NULL)
{
    if(!is.null(random_seed))
        set.seed(random_seed)

    umap_config <- umap.defaults
    umap_config$n_neighbors <- n_neighbors
    umap_proj <- umap(dm, input = "dist", config = umap_config)
    
    return(
        data.frame(
            peak_id = rownames(dm),
            umap_1 = umap_proj$layout[, 1],
            umap_2 = umap_proj$layout[, 2]
        )
    )
}

plot_umap <- function(umap_proj, colors = "black")
{
    umap_proj %>%
        ggplot(aes(x = umap_1, y = umap_2)) +
        geom_point(alpha = 0.7, colour = colors) +
        theme_classic()
}

plot_umap_interactive <- function(umap_proj, tooltips)
{
    ggplotly(
        umap_proj %>% mutate(tooltip = tooltips) %>%
            ggplot(aes(x = umap_1, y = umap_2, label = peak_id, text = tooltip)) +
            geom_text() +
            theme_classic(),
        tooltip = "text"
    )
}

# extract known neighbors from a peak list
nearest_known_table <- function(neighbors_ids, peak_list)
{
    data.frame(peak_id = neighbors_ids, rank = 1:length(neighbors_ids)) %>%
        inner_join(
            peak_list %>% filter(!is.na(known_met_id)),
            join_by('peak_id')) %>%
        select(rank, known_met_id, inchi_key, name)
}


# file paths for simulated distance matrices with noise
sim_dir_path <- function(stdev)
{
   file.path(
      sim_mid_distance_path,
      paste('stdev', stdev, sep = '_')
   )
}

sim_mi_data_file_name <- function(rep_nr)
{
   paste0(paste('rep', rep_nr, 'midata', sep = '_'), '.rds')
}

sim_mi_data_path <- function(stdev, rep_nr)
{
   file.path(sim_dir_path(stdev), sim_mi_data_file_name(rep_nr))
}

sim_dm_file_name <- function(rep_nr)
{
   paste0(paste('rep', rep_nr, 'dm', sep = '_'), '.rds')
}

sim_dm_path <- function(stdev, rep_nr)
{
   file.path(sim_dir_path(stdev), sim_dm_file_name(rep_nr))
}

# for distance matrices for subsets of metabolites
subset_dir_path <- function(subset_size)
{
   file.path(sim_mid_distance_path, paste('subset', subset_size, sep = '_'))
}

subset_mi_data_path <- function(subset_size, rep_nr)
{
   file.path(subset_dir_path(subset_size), sim_mi_data_file_name(rep_nr))
}

subset_dm_path <- function(subset_size, rep_nr)
{
   file.path(subset_dir_path(subset_size), sim_dm_file_name(rep_nr))

}


