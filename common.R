#
#  Some functions commonly used in these scripts
#
# NOTE: Some of these could be moved to the remn package
#

library(dplyr)

# some common paths

project_path <-  file.path(
    "C:", "Users", "rolnil", "OneDrive - KI.SE", "Lab common", "projects",
    "reverse-engineering-deniz"
)
data_path <- file.path(project_path, "data-for-publication")



# convolute MID matrices column by column
convolute_all <- function(mids_1, mids_2)
{
    sapply(
        1:ncol(mids_1),
        function(i) convolute(mids_1[, i], mids_2[, i])
    )
}


# Read the HMEC peak list and subset to QC peaks
read_hmec_qc_peak_list <- function()
{
    # Read list of peaks passing QC
    qc_list_path <- file.path(data_path, "peak-qc-list.tsv")
    stopifnot(file.exists(qc_list_path))
    peak_qc_list <- read.table(
        qc_list_path,
        sep = "\t", header = TRUE
    ) %>% filter(qc == 1) %>% select(peak_id)
    
    # Read peak list
    peak_list_path <- file.path(data_path, "nodelist-netid-pos-neg.csv")
    stopifnot(file.exists(peak_list_path))
    hmec_peak_list <- read.delim(
        peak_list_path,
        sep = ",", header = TRUE
    )
    # peak IDs
    hmec_peak_list <- hmec_peak_list %>% mutate(peak_id = row_number())
    # subset to QC peaks
    hmec_peak_list <- hmec_peak_list %>%
        inner_join(peak_qc_list, by = join_by(peak_id))
    # drop unused fields
    hmec_peak_list <- hmec_peak_list %>%
        select(peak_id, mass, path, ion_mode) %>%
        rename(netid_annotation = path)
    return(hmec_peak_list)
}

# Read peak area data from the HMEC isotope tracing experiment
read_hmec_peak_areas <- function()
{
    peak_areas_path <- file.path(data_path, "hmec-peak-areas.tsv")
    stopifnot(file.exists(peak_areas_path))
    hmec_peak_areas <- read.table(
        peak_areas_path,
        sep = "\t", header = TRUE, check.names = FALSE
    )
    # order columns alphabetic by tracer, unlabeled last
#    column_order <- c(1:2, (3:65)[order(colnames(hmec_peak_areas)[3:65])], 66:68)
#    return(hmec_peak_areas[column_order])
}

# retrieve a matrix of MIDs (with replicates) for a given peak list
get_mid_matrix <- function(mi_data, peak_id, experiments = NULL)
{
    peak_index <- match(peak_id, mi_data$peak_ids)
    if(is.null(experiments))
        exp_index <- 1:length(mi_data$experiments)  # plot all experiments
    else
        exp_index <- match(experiments, mi_data$experiments)
    return(
        do.call(cbind,
                lapply(
                    exp_index,
                    function(e) get_mids(mi_data, peak_index, e)
                )
        )
    )
}


# write matrix as PNG image (for Illustrator) after applying a color function
# such as those generated by colorRamp()
# rows of the matrix are laid out from top to bottom.
write_image <- function(file_path, mat, color_fn)
{
    png::writePNG(
        aperm(
            apply(mat, c(1,2), color_fn) / 255,
            c(2,3,1)
        ),
        file_path
    )
}

reverse_rows <- function(mat)
{
    return(mat[nrow(mat):1, ])
}

# write an MID matrix, dropping M+0 and rescaling to [0, 1]
write_mid_matrix_image <- function(file_name, mids)
{
    mat <- reverse_rows(c13correct_cols(mids)[-1, ])
    cat("Scaling image to max = ", max(mat))
    write_image(
        file_name, mat / max(mat), colorRamp(c("white", "red"))
    )
}


